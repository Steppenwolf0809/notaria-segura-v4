generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Notary {
  id         String    @id @default(uuid()) @db.Uuid
  code       String    @unique
  slug       String    @unique
  name       String
  ruc        String?
  email      String?
  phone      String?
  address    String?
  city       String?
  province   String?
  clerkOrgId String?   @unique @map("clerk_org_id")
  isActive   Boolean   @default(true) @map("is_active")
  deletedAt  DateTime? @map("deleted_at")
  config     Json?
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  users      User[]

  @@index([isActive])
  @@index([deletedAt])
  @@map("notaries")
}

model User {
  id                         Int                        @id @default(autoincrement())
  email                      String                     @unique
  clerkUserId                String?                    @unique @map("clerk_user_id")
  password                   String
  firstName                  String
  lastName                   String
  role                       UserRole
  notaryId                   String?                    @db.Uuid @map("notary_id")
  isActive                   Boolean                    @default(true)
  deletedAt                  DateTime?                  @map("deleted_at")
  createdAt                  DateTime                   @default(now())
  updatedAt                  DateTime                   @updatedAt
  lastLogin                  DateTime?
  notary                     Notary?                    @relation(fields: [notaryId], references: [id])
  auditoriaPersonas          AuditoriaPersona[]
  documentEvents             DocumentEvent[]
  documents                  Document[]                 @relation("AssignedDocuments")
  createdDocuments           Document[]                 @relation("CreatedDocuments")
  deliveredDocuments         Document[]                 @relation("DeliveredDocuments")
  escriturasQR               EscrituraQR[]
  formularioUAFEAsignaciones FormularioUAFEAsignacion[]
  protocolosUAFE             ProtocoloUAFE[]
  importLogs                 ImportLog[]
  mensajesEnviados           MensajeInterno[]           @relation("MensajesEnviados")
  mensajesRecibidos          MensajeInterno[]           @relation("MensajesRecibidos")
  assignedInvoices           Invoice[]                  @relation("AssignedInvoices")

  @@index([notaryId])
  @@index([deletedAt])
  @@map("users")
}

model Document {
  id                       String                 @id @default(uuid())
  protocolNumber           String                 @unique
  clientName               String
  clientPhone              String?
  clientEmail              String?
  clientId                 String?
  detalle_documento        String?
  comentarios_recepcion    String?
  documentType             String
  status                   String                 @default("PENDIENTE")
  verificationCode         String?
  assignedToId             Int?
  createdById              Int
  actoPrincipalDescripcion String
  actoPrincipalValor       Float
  totalFactura             Float
  matrizadorName           String
  itemsSecundarios         String?
  xmlOriginal              String?
  numeroFactura            String?   // N√∫mero de factura del SRI (formato: 001-002-000123676)
  codigoRetiro             String?
  entregadoA               String?
  cedulaReceptor           String?
  relacionTitular          String?
  verificacionManual       Boolean                @default(false)
  facturaPresenta          Boolean                @default(false)
  fechaEntrega             DateTime?
  usuarioEntregaId         Int?
  observacionesEntrega     String?
  notaCreditoMotivo        String?
  notaCreditoEstadoPrevio  String?
  notaCreditoFecha         DateTime?
  createdAt                DateTime               @default(now())
  updatedAt                DateTime               @updatedAt
  fechaFactura             DateTime?
  
  // Trazabilidad de notificaciones WhatsApp
  fechaListo               DateTime?              // Timestamp al pasar a LISTO
  ultimoRecordatorio       DateTime?              // √öltima notificaci√≥n enviada
  
  // Gesti√≥n interna
  pagoConfirmado           Boolean                @default(false)
  alertaInterna            Boolean                @default(false)
  mensajeInterno           String?
  
  events                   DocumentEvent[]
  assignedTo               User?                  @relation("AssignedDocuments", fields: [assignedToId], references: [id])
  createdBy                User                   @relation("CreatedDocuments", fields: [createdById], references: [id])
  usuarioEntrega           User?                  @relation("DeliveredDocuments", fields: [usuarioEntregaId], references: [id])
  notifications            WhatsAppNotification[]
  invoices                  Invoice[]
  mensajesInternos          MensajeInterno[]

  @@index([status])
  @@index([createdAt])
  @@index([updatedAt])
  @@index([clientPhone])
  @@index([clientName])
  @@index([clientId])
  @@index([assignedToId, status])
  @@map("documents")
}

model DocumentEvent {
  id                  String    @id @default(uuid())
  documentId          String?
  userId              Int
  eventType           String    @default("UNKNOWN")
  description         String
  details             String?
  personaRetiro       String?
  cedulaRetiro        String?
  metodoVerificacion  String?
  observacionesRetiro String?
  ipAddress           String?
  userAgent           String?
  createdAt           DateTime  @default(now())
  document            Document? @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user                User      @relation(fields: [userId], references: [id])

  @@index([documentId, createdAt])
  @@index([userId])
  @@index([eventType])
  @@map("document_events")
}

model WhatsAppNotification {
  id           String         @id @default(uuid())
  documentId   String?
  clientName   String
  clientPhone  String
  messageType  String
  messageBody  String
  status       String         @default("PENDING")
  messageId    String?
  errorMessage String?
  sentAt       DateTime?
  createdAt    DateTime       @default(now())
  document     Document?      @relation(fields: [documentId], references: [id])

  @@index([status])
  @@index([documentId])
  @@index([createdAt])
  @@map("whatsapp_notifications")
}

model WhatsAppTemplate {
  id        String   @id @default(uuid())
  tipo      String
  titulo    String
  mensaje   String
  activo    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("whatsapp_templates")
}

model TestConnection {
  id        Int      @id @default(autoincrement())
  message   String   @default("Conexi√≥n exitosa")
  createdAt DateTime @default(now())

  @@map("test_connection")
}

model SystemSetting {
  id        String   @id @default(uuid())
  key       String   @unique
  value     String
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  @@index([key])
  @@map("system_settings")
}

model EscrituraQR {
  id                    Int       @id @default(autoincrement())
  token                 String    @unique
  numeroEscritura       String?
  datosCompletos        String?
  archivoOriginal       String?
  estado                String    @default("activo")
  activo                Boolean   @default(true)
  createdBy             Int?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  extractoTextoCompleto String?
  origenDatos           String    @default("PDF")
  fotoURL               String?
  pdfFileName           String?
  pdfUploadedAt         DateTime?
  pdfUploadedBy         Int?
  pdfFileSize           Int?
  pdfViewCount          Int       @default(0)
  pdfHiddenPages        String?
  verifyViewCount       Int       @default(0)  // Contador de visitas a p√°gina de verificaci√≥n
  creador               User?     @relation(fields: [createdBy], references: [id])

  @@index([token])
  @@index([estado])
  @@index([createdAt])
  @@index([createdBy])
  @@index([origenDatos])
  @@map("escrituras_qr")
}

model PersonaRegistrada {
  id                         String                     @id @default(uuid())
  numeroIdentificacion       String                     @unique
  tipoPersona                String
  pinHash                    String
  pinCreado                  Boolean                    @default(false)
  pinResetCount              Int                        @default(0)
  intentosFallidos           Int                        @default(0)
  bloqueadoHasta             DateTime?
  ultimoAcceso               DateTime?
  ultimoIntentoFallido       DateTime?
  datosPersonaNatural        Json?
  datosPersonaJuridica       Json?
  completado                 Boolean                    @default(false)
  createdAt                  DateTime                   @default(now())
  updatedAt                  DateTime                   @updatedAt
  auditoria                  AuditoriaPersona[]
  formularioAsignaciones     FormularioUAFEAsignacion[]
  formularioRespuestas       FormularioUAFERespuesta[]
  protocolos                 PersonaProtocolo[]         @relation("Compareciente")
  protocolosComoRepresentado PersonaProtocolo[]         @relation("Representado")
  sesiones                   SesionPersonal[]

  @@index([numeroIdentificacion])
  @@index([bloqueadoHasta])
  @@map("personas_registradas")
}

model SesionPersonal {
  id              String            @id @default(uuid())
  personaId       String
  token           String            @unique
  expiraEn        DateTime
  ultimaActividad DateTime          @default(now())
  ipAddress       String?
  userAgent       String?
  createdAt       DateTime          @default(now())
  persona         PersonaRegistrada @relation(fields: [personaId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([personaId])
  @@index([expiraEn])
  @@map("sesiones_personales")
}

model AuditoriaPersona {
  id           String            @id @default(uuid())
  personaId    String
  tipo         String
  descripcion  String
  matrizadorId Int?
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime          @default(now())
  matrizador   User?             @relation(fields: [matrizadorId], references: [id])
  persona      PersonaRegistrada @relation(fields: [personaId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@index([tipo])
  @@index([createdAt])
  @@map("auditoria_personas")
}

model FormularioUAFEAsignacion {
  id             String                   @id @default(uuid())
  personaId      String
  numeroMatriz   String
  actoContrato   String
  calidadPersona String
  actuaPor       String
  token          String                   @unique
  estado         String                   @default("PENDIENTE")
  expiraEn       DateTime?
  matrizadorId   Int
  respuestaId    String?                  @unique
  createdAt      DateTime                 @default(now())
  completadoEn   DateTime?
  matrizador     User                     @relation(fields: [matrizadorId], references: [id])
  persona        PersonaRegistrada        @relation(fields: [personaId], references: [id], onDelete: Cascade)
  respuesta      FormularioUAFERespuesta? @relation(fields: [respuestaId], references: [id])

  @@index([token])
  @@index([personaId])
  @@index([matrizadorId])
  @@index([estado])
  @@index([numeroMatriz])
  @@map("formulario_uafe_asignaciones")
}

model FormularioUAFERespuesta {
  id                         String                    @id @default(uuid())
  asignacionId               String                    @unique
  personaId                  String
  fecha                      DateTime
  numeroMatriz               String
  actoContrato               String
  avaluoMunicipal            Float?
  valorContrato              Float?
  formaPagoCheque            Boolean                   @default(false)
  formaPagoEfectivo          Boolean                   @default(false)
  formaPagoTransferencia     Boolean                   @default(false)
  formaPagoTarjeta           Boolean                   @default(false)
  montoCheque                Float?
  montoEfectivo              Float?
  montoTransferencia         Float?
  montoTarjeta               Float?
  bancoCheque                String?
  bancoTransferencia         String?
  bancoTarjeta               String?
  calidad                    String
  actuaPor                   String
  tipoIdentificacion         String
  numeroIdentificacion       String
  nacionalidad               String
  estadoCivil                String
  genero                     String
  nivelEstudio               String
  callePrincipal             String
  numeroDomicilio            String?
  calleSecundaria            String?
  situacionLaboral           String
  relacionDependencia        Boolean?
  nombreEntidad              String?
  fechaIngreso               DateTime?
  direccionLaboral           String?
  provinciaLaboral           String?
  cantonLaboral              String?
  profesionOcupacion         String?
  cargo                      String?
  ingresoMensual             Float?
  tieneConyugue              Boolean                   @default(false)
  conyugeApellidos           String?
  conyugeNombres             String?
  conyugeTipoId              String?
  conyugeNumeroId            String?
  conyugeNacionalidad        String?
  conyugeEstadoCivil         String?
  conyugeGenero              String?
  conyugeNivelEstudio        String?
  conyugeCorreo              String?
  conyugeCelular             String?
  conyugeCallePrincipal      String?
  conyugeNumero              String?
  conyugeCalleSecundaria     String?
  conyugeProfesion           String?
  conyugeSituacionLaboral    String?
  conyugeRelacionDependencia Boolean?
  conyugeNombreEntidad       String?
  conyugeFechaIngreso        DateTime?
  conyugeDireccionLaboral    String?
  conyugeProvinciaLaboral    String?
  conyugeCantonLaboral       String?
  tieneBeneficiario          Boolean                   @default(false)
  beneficiarioApellidos      String?
  beneficiarioNombres        String?
  beneficiarioTipoId         String?
  beneficiarioNumeroId       String?
  beneficiarioNacionalidad   String?
  beneficiarioEstadoCivil    String?
  beneficiarioGenero         String?
  beneficiarioNivelEstudio   String?
  beneficiarioProfesion      String?
  beneficiarioDireccion      String?
  beneficiarioCorreo         String?
  beneficiarioTelefono       String?
  beneficiarioCelular        String?
  esPEP                      Boolean                   @default(false)
  esFamiliarPEP              Boolean                   @default(false)
  relacionPEP                String?
  esColaboradorPEP           Boolean                   @default(false)
  tipoColaborador            String?
  completadoEn               DateTime                  @default(now())
  ipAddress                  String?
  userAgent                  String?
  asignacion                 FormularioUAFEAsignacion?
  persona                    PersonaRegistrada         @relation(fields: [personaId], references: [id], onDelete: Cascade)

  @@index([personaId])
  @@index([asignacionId])
  @@index([numeroMatriz])
  @@index([completadoEn])
  @@map("formulario_uafe_respuestas")
}

model ProtocoloUAFE {
  id                      String             @id @default(uuid())
  
  // IDENTIFICACI√ìN (numeroProtocolo ahora opcional para borradores)
  numeroProtocolo         String?            @unique
  identificadorTemporal   String             @unique @default(uuid())
  
  // TIPO Y FECHA
  fecha                   DateTime
  tipoActo                String             // COMPRAVENTA, PROMESA_COMPRAVENTA, DONACION, etc.
  actoContrato            String?            // Mantenido para retrocompatibilidad
  
  // VALORES
  valorContrato           Decimal            @db.Decimal(12, 2)
  avaluoMunicipal         Decimal?           @db.Decimal(12, 2)
  multa                   Decimal?           @db.Decimal(12, 2) // Solo para PROMESA_COMPRAVENTA
  formasPago              Json?
  
  // UBICACI√ìN DEL INMUEBLE (separado en campos individuales)
  ubicacionDescripcion    String?            @db.Text // Descripci√≥n del lote/predio
  ubicacionParroquia      String?
  ubicacionCanton         String?            @default("QUITO")
  ubicacionProvincia      String?            @default("PICHINCHA")
  
  // CAMPOS LEGACY (mantener para compatibilidad)
  bienInmuebleDescripcion String?
  bienInmuebleUbicacion   String?
  
  // DATOS DE VEH√çCULO (para actas de reconocimiento)
  vehiculoAnio            String?
  vehiculoMarca           String?
  vehiculoModelo          String?
  vehiculoPlaca           String?
  vehiculoCiudadComercializacion String?      // Ciudad donde se comercializa
  
  // OTROS
  tipoActoOtro            String?
  
  // CACHE DE TEXTOS GENERADOS
  textoEncabezadoGenerado    String?         @db.Text
  textoComparecenciaGenerado String?         @db.Text
  fechaUltimaGeneracion      DateTime?
  
  // AUDITOR√çA
  createdBy               Int
  createdAt               DateTime           @default(now())
  updatedAt               DateTime           @updatedAt
  
  // RELACIONES
  personas                PersonaProtocolo[]
  creador                 User               @relation(fields: [createdBy], references: [id])

  @@index([numeroProtocolo])
  @@index([identificadorTemporal])
  @@index([tipoActo])
  @@index([createdBy])
  @@index([createdAt])
  @@map("protocolos_uafe")
}

model PersonaProtocolo {
  id                  String                 @id @default(uuid())
  protocoloId         String
  personaCedula       String
  
  // IDENTIFICACI√ìN FLEXIBLE (para personas no registradas a√∫n)
  nombreTemporal      String?                // Null si persona existe en BD
  
  // ROL EN ESTE TR√ÅMITE
  calidad             String                 // VENDEDOR, COMPRADOR, DONANTE, etc.
  actuaPor            String                 // PROPIOS_DERECHOS, REPRESENTANDO_SOCIEDAD_CONYUGAL, COMO_APODERADO
  
  // ESTADO DE COMPLETITUD (para sem√°foro üî¥üü°üü¢)
  estadoCompletitud   String                 @default("pendiente") // pendiente, incompleto, completo
  porcentajeCompletitud Int                  @default(0) // 0-100%
  camposFaltantes     Json?                  // Lista de campos que faltan para verde
  
  // CAMPOS PARA REDACCI√ìN
  compareceConyugeJunto Boolean              @default(false) // Si comparece con su c√≥nyuge
  esApoderado         Boolean                @default(false) // Si act√∫a como apoderado
  mandanteCedula      String?                // C√©dula del mandante si es apoderado
  mandanteNombre      String?                // Nombre del mandante
  
  // ORDEN de aparici√≥n en documentos
  orden               Int                    @default(0)
  
  // CAMPOS LEGACY
  completado          Boolean                @default(false)
  completadoAt        DateTime?
  respuestaFormulario Json?
  representadoId      String?
  datosRepresentado   Json?
  
  // TIMESTAMPS
  createdAt           DateTime               @default(now())
  updatedAt           DateTime               @updatedAt
  
  // RELACIONES
  persona             PersonaRegistrada      @relation("Compareciente", fields: [personaCedula], references: [numeroIdentificacion])
  protocolo           ProtocoloUAFE          @relation(fields: [protocoloId], references: [id], onDelete: Cascade)
  representado        PersonaRegistrada?     @relation("Representado", fields: [representadoId], references: [numeroIdentificacion])
  sesiones            SesionFormularioUAFE[]

  @@unique([protocoloId, personaCedula])
  @@index([protocoloId])
  @@index([personaCedula])
  @@index([completado])
  @@index([estadoCompletitud])
  @@index([representadoId])
  @@map("personas_protocolo")
}

model SesionFormularioUAFE {
  id                 String           @id @default(uuid())
  personaProtocoloId String
  token              String           @unique
  expiraEn           DateTime
  ultimaActividad    DateTime         @default(now())
  ipAddress          String?
  userAgent          String?
  createdAt          DateTime         @default(now())
  personaProtocolo   PersonaProtocolo @relation(fields: [personaProtocoloId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([personaProtocoloId])
  @@index([expiraEn])
  @@map("sesiones_formulario_uafe")
}

model EncuestaSatisfaccion {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  tramiteId    String?  // ID proveniente de URL param (?ref=...)
  calificacion Int      // 1 a 5
  infoClara    Boolean
  tratoCordial Boolean
  sugerencia   String?  @db.Text

  @@index([createdAt])
  @@index([calificacion])
  @@map("encuestas_satisfaccion")
}

// ========================================
// SISTEMA DE MENSAJES INTERNOS
// ========================================

model MensajeInterno {
  id              Int       @id @default(autoincrement())
  
  // Relaciones
  remitenteId     Int
  remitente       User      @relation("MensajesEnviados", fields: [remitenteId], references: [id])
  
  destinatarioId  Int
  destinatario    User      @relation("MensajesRecibidos", fields: [destinatarioId], references: [id])
  
  // Contexto del mensaje
  documentoId     String?
  documento       Document? @relation(fields: [documentoId], references: [id])
  
  facturaId       Int?      // Para mensajes de cobro (futuro)
  
  // Contenido
  tipo            String    // "SOLICITUD_ACTUALIZACION", "PRIORIZAR", "CLIENTE_ESPERANDO", "COBRO", "OTRO"
  urgencia        String    @default("NORMAL") // "NORMAL", "URGENTE", "CRITICO"
  mensaje         String?   // Mensaje personalizado opcional
  
  // Estado
  leido           Boolean   @default(false)
  leidoAt         DateTime?

  // Resoluci√≥n - cuando el matrizador completa la acci√≥n solicitada
  resuelto        Boolean   @default(false)
  resueltoAt      DateTime?
  notaResolucion  String?   // Nota opcional de qu√© se hizo

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@map("mensajes_internos")
  @@index([destinatarioId, leido])
  @@index([documentoId])
  @@index([createdAt])
}

enum UserRole {
  SUPER_ADMIN
  ADMIN
  CAJA
  MATRIZADOR
  RECEPCION
  ARCHIVO
}

// ========================================
// M√ìDULO DE FACTURACI√ìN
// ========================================

model Invoice {
  id                String        @id @default(uuid())
  
  // Identificaci√≥n (√öNICO)
  invoiceNumber     String        @unique  // numtra normalizado: 001-002-000123341
  invoiceNumberRaw  String                 // numtra original: 001002-00123341
  
  // Datos del cliente (desnormalizados del CSV, para facturas sin documento)
  clientTaxId       String                 // codcli (c√©dula/RUC)
  clientName        String                 // nomcli
  
  // Montos
  totalAmount       Decimal       @db.Decimal(12, 2)  // valcob de FC (incluye IVA)
  subtotalAmount    Decimal?      @db.Decimal(12, 2)  // Base Imponible (sin IVA) ‚Äî para Participaci√≥n al Estado
  paidAmount        Decimal?      @db.Decimal(12, 2) @default(0)  // Suma incremental de pagos
  
  // Fechas
  issueDate         DateTime               // fecemi (en FC) o fectra (en AB para legacy)
  dueDate           DateTime?              // fecven
  
  // Referencia
  concept           String?                // concep
  
  // Estado y control
  status            InvoiceStatus @default(PENDING)
  isLegacy          Boolean       @default(false)  // Creada por pago hu√©rfano
  
  // Vinculaci√≥n con documento notarial (autom√°tica por numeroFactura)
  documentId        String?
  document          Document?     @relation(fields: [documentId], references: [id])
  
  // Asignaci√≥n directa de matrizador (para facturas sin documento)
  assignedToId      Int?
  assignedTo        User?         @relation("AssignedInvoices", fields: [assignedToId], references: [id])
  
  // Metadata de importaci√≥n
  importedAt        DateTime      @default(now())
  lastSyncAt        DateTime      @updatedAt
  sourceFile        String?                // Nombre del archivo de origen
  matrizador        String?                // Nombre del matrizador (codven mapeado)
  
  // ========================================
  // CAMPOS DE SINCRONIZACI√ìN KOINOR
  // ========================================
  
  // Vinculaci√≥n por protocolo (para match con Document.protocolNumber)
  numeroProtocolo     String?               // "20261701018P00252" - del campo observ de Koinor
  
  // Condici√≥n de pago
  condicionPago       String?               // "C" = cr√©dito, "E" = contado
  
  // Desglose de pagos al contado (pagos directos en facturaci√≥n)
  pagoEfectivo        Decimal? @db.Decimal(12, 2) @default(0)
  pagoCheque          Decimal? @db.Decimal(12, 2) @default(0)
  pagoTarjeta         Decimal? @db.Decimal(12, 2) @default(0)
  pagoDeposito        Decimal? @db.Decimal(12, 2) @default(0)
  pagoDirecto         Decimal? @db.Decimal(12, 2) @default(0)  // Suma de pagos al contado
  
  // Pagos posteriores (via CxC)
  montoPagadoCxc      Decimal? @db.Decimal(12, 2) @default(0)  // Pagos posteriores via CxC
  
  // Notas de cr√©dito
  montoNotaCredito    Decimal? @db.Decimal(12, 2) @default(0)
  tieneNotaCredito    Boolean  @default(false)
  
  // Saldo y fechas de pago
  fechaUltimoPago     DateTime?
  saldoPendiente      Decimal? @db.Decimal(12, 2) @default(0)
  
  // Metadata de sincronizaci√≥n Koinor
  koinorModifiedAt    DateTime?             // ultima_modificacion de la VIEW de Koinor
  syncSource          String?  @default("MANUAL")  // "MANUAL", "KOINOR_SYNC", "XML_IMPORT"
  
  // Relaciones
  payments          Payment[]
  
  @@map("invoices")
  @@index([invoiceNumber])
  @@index([invoiceNumberRaw])
  @@index([clientTaxId])
  @@index([status])
  @@index([issueDate])
  @@index([documentId])
  @@index([numeroProtocolo])
}

model Payment {
  id              String      @id @default(uuid())
  
  // Identificaci√≥n (NO √∫nico - un recibo puede pagar m√∫ltiples facturas)
  receiptNumber   String      // numdoc: 001-2601000089
  
  // Monto
  amount          Decimal     @db.Decimal(12, 2)  // valcob de AB
  
  // Fechas
  paymentDate     DateTime               // fecemi
  
  // Referencias
  concept         String?                // concep (ej: "PAGO FACT 119478 05/09")
  accountingRef   String?                // numcco (comprobante contable)
  
  // Tipo de pago
  paymentType     PaymentType @default(CASH)
  
  // Factura asociada
  invoiceId       String
  invoice         Invoice     @relation(fields: [invoiceId], references: [id])
  
  // Metadata
  importedAt      DateTime    @default(now())
  sourceFile      String?
  
  @@map("payments")
  @@index([receiptNumber])
  @@index([invoiceId])
  @@index([paymentDate])
}

model ImportLog {
  id              String       @id @default(uuid())
  
  // Informaci√≥n del archivo
  fileName        String
  fileType        String               // 'POR_COBRAR' o 'CXC'
  
  // Estad√≠sticas
  totalRows       Int
  invoicesCreated Int          @default(0)
  invoicesUpdated Int          @default(0)
  paymentsCreated Int          @default(0)
  paymentsSkipped Int          @default(0)
  errors          Int          @default(0)
  
  // Rango de fechas procesado
  dateFrom        DateTime?
  dateTo          DateTime?
  
  // Estado
  status          ImportStatus @default(PROCESSING)
  errorDetails    Json?
  metadata        Json?                // Estad√≠sticas adicionales (FC, NC, etc.)
  
  // Usuario que ejecut√≥
  executedBy      Int?
  executedByUser  User?        @relation(fields: [executedBy], references: [id])
  
  // Timestamps
  startedAt       DateTime     @default(now())
  completedAt     DateTime?
  
  @@map("import_logs")
  @@index([status])
  @@index([startedAt])
}

enum InvoiceStatus {
  PENDING       // Pendiente de pago
  PARTIAL       // Pago parcial
  PAID          // Pagada completamente
  OVERDUE       // Vencida
  CANCELLED     // Anulada
}

enum PaymentType {
  CASH          // Efectivo
  TRANSFER      // Transferencia
  CHECK         // Cheque
  RETENTION     // Retenci√≥n
  CREDIT_NOTE   // Nota de cr√©dito
  OTHER         // Otro
}

enum ImportStatus {
  PROCESSING
  COMPLETED
  COMPLETED_WITH_ERRORS
  FAILED
}

// ============================================
// CUENTAS POR COBRAR (CXC) - CARTERA PENDIENTE
// Tabla separada de invoices.
// Almacena la foto completa de saldos pendientes
// sincronizada autom√°ticamente desde Koinor.
// Incluye deudas hist√≥ricas que invoices no conoce.
// ============================================

model PendingReceivable {
  id                String   @id @default(uuid())

  // === IDENTIFICACI√ìN DEL CLIENTE ===
  clientTaxId       String                        // C√©dula/RUC del cliente
  clientName        String                        // Nombre del cliente

  // === IDENTIFICACI√ìN DE LA FACTURA ===
  invoiceNumberRaw  String   @unique              // N√∫mero factura original (ej: "001002-00124369")
  invoiceNumber     String?                       // N√∫mero normalizado (ej: "001-002-000124369")

  // === MONTOS ===
  totalAmount       Decimal  @db.Decimal(12, 2)   // Valor original de la factura
  balance           Decimal  @db.Decimal(12, 2)   // Saldo pendiente actual
  totalPaid         Decimal  @db.Decimal(12, 2) @default(0)  // Monto total pagado

  // === FECHAS ===
  issueDate         DateTime?                     // Fecha de emisi√≥n de la factura
  dueDate           DateTime?                     // Fecha de vencimiento
  lastPaymentDate   DateTime?                     // Fecha del √∫ltimo pago recibido

  // === ESTADO ===
  status            String   @default("PENDING")  // PENDING, PARTIAL, PAID, OVERDUE, CANCELLED
  daysOverdue       Int      @default(0)          // D√≠as de mora (calculado en cada sync)
  hasCreditNote     Boolean  @default(false)      // Tiene nota de cr√©dito aplicada

  // === ASIGNACI√ìN ===
  matrizador        String?                       // Nombre del matrizador (codven mapeado desde Koinor)

  // === COMENTARIOS DE GESTI√ìN (CAJA) ===
  cashierComment              String?             // Comentario operativo visible en Caja/Admin/Matrizador
  cashierCommentUpdatedAt     DateTime?           // √öltima actualizaci√≥n del comentario
  cashierCommentUpdatedById   Int?                // Usuario que actualiz√≥ el comentario
  cashierCommentUpdatedByName String?             // Nombre visible del usuario que actualiz√≥

  // === METADATA DE SINCRONIZACI√ìN ===
  lastSyncAt        DateTime @default(now())      // √öltima vez que se actualiz√≥ desde Koinor
  syncSource        String   @default("SYNC_AGENT") // SYNC_AGENT o MANUAL_XLS

  // === TIMESTAMPS ===
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // === √çNDICES ===
  @@index([clientTaxId])
  @@index([status])
  @@index([balance])
  @@index([dueDate])
  @@index([lastSyncAt])
  @@index([matrizador])
  @@index([cashierCommentUpdatedAt])
  @@map("pending_receivables")
}

// ============================================
// SINCRONIZACI√ìN KOINOR ‚Üí RAILWAY
// Registro de cada sincronizaci√≥n del Sync Agent
// ============================================

model SyncLog {
  id                String   @id @default(uuid())
  
  // === RESULTADO ===
  status            String   // "SUCCESS", "PARTIAL", "ERROR"
  
  // === M√âTRICAS ===
  totalReceived     Int      @default(0)   // Registros recibidos
  created           Int      @default(0)   // Nuevos registros creados
  updated           Int      @default(0)   // Registros actualizados
  unchanged         Int      @default(0)   // Sin cambios (skipped)
  errors            Int      @default(0)   // Errores individuales
  documentsLinked   Int      @default(0)   // Documents vinculados por protocolo
  
  // === TIMING ===
  syncStartedAt     DateTime               // Cu√°ndo empez√≥
  syncCompletedAt   DateTime @default(now()) // Cu√°ndo termin√≥
  durationMs        Int      @default(0)   // Duraci√≥n en milisegundos
  
  // === METADATA ===
  agentVersion      String?                // Versi√≥n del Sync Agent
  errorDetails      String?  @db.Text      // Detalles de errores (JSON string)
  
  @@map("sync_logs")
  @@index([syncCompletedAt])
  @@index([status])
}

